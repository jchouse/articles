# Структура файлов в Реакт приложении.

## Вступление
Проблема организации файлов внутри приложения не возникает на пустом месте, как правило над этим задумываются когда на проекте работает больше одного человека и размер кодовой базы вырастает до такого уровня, что сложно удержать в памяти кой файл за какую часть приложения отвечает. Т.е. мы всегда пытаемся сделать структуру такой чтобы ее можно было использовать комфортно и быстро.

React не дикутет свою архитектуру приложения, оставляя полную свободу действий в организации файлов приложения: https://reactjs.org/docs/faq-structure.html

Чтобы дать немного контекста раскажу о решениях и технологиях используемых внутри нашего проекта:
1. Осноный язык приложения TypeScript.
1. Основная библиотека, как я уже упомянул: React.
1. Стейт менеджер MobX.
1. Стили JSS
1. Testing - JEST

Добавлю еще немного. Изначальнов весь код был написан на ES+Redux. Потом, история умолчаивает и мне остается лишь догадываться почему, было принято решение переписать живущий уже 5 лет проект где был добавлен уже почти весь минимальный набор функций чтобы суметь продаваться и не работать в убыток, на TS+MobX. Конечно еслибы сейчас мне дали выбор и спросили на чем я хочу написать новый проект я бы выбрал Redux на TS_MobX, но опять же если бы мне сейчас предложили переписать сущестувующий проект с одного стека на другой я бы, пожалуй, отказался. Пишите в коментах если хотите услышать эту историю.

Также в процессе поиска решения я использовал наработки и мысли авторов статей:
1) https://www.taniarascia.com/react-architecture-directory-structure/
1) https://www.robinwieruch.de/react-folder-structure/

## Существующие решения
Изначально структура нашего проекта была заточена на глобальный стейт, но в тоже время имела псевдомодульную структуру с избыточной вложенностью. Почему я считаю нашу предыдушую структуру псевдомоудльной? Уровень зависимостей между модулями был очень высокий и не позволял без адского дублирования взять и вынести один из модулей в отедльный репозиторий, т.е. ничего кроме как усложенения структуры и багатой вложенности это нам не давало. Приблизительно это выглядит вот так:

```
.
├── /modules
│   └── /ModuleName1
│        └── /src
│            └── /js
│                ├── /api
│                ├── /actions
│                ├── /components
│                ├── /containers
│                ├── /reducers
│                └── /stores
└── /src
    ├── /api
    ├── /assets
    ├── /components
    ├── /constants
    ├── /containers
    ├── /icons
    ├── /reducers
    ├── /stores
    ├── /styles
    ├── /utils
    ├── index.js
    └── App.js
```

Можно смело предположить что данное решение основаное на принятом в сообществе разработчиков фронтенда разделения файлов, которое основывается на функциональном назанчении кода внутри, вот пример такого варианта.

```
.
└── /src
    ├── /actions
    ├── /assets
    ├── /components
    ├── /constants
    ├── /containers
    ├── /icons
    ├── /reducers
    ├── /stores
    ├── /styles
    ├── /utils
    ├── index.js
    └── App.js
```
Оба подхода имеют право на сушествование и, справделивости ради стоит заметить, пример выше при умелом использовании алиасов для WebPack и index.ts нивилируют проблему избыточной вложенности. Но требуют дополнительных действий от владельцев кода репозитория, ну и более тщательного ревью кода.

Что же изменилось с отказом от глобального стора Redux (и всех сопуствющих библиотек Thunk, reselect, Recompose, etc). Появилась возможность писать атомарные сторы, т.е. когда стор пишется кокретно под компонент и может быть подключен в провайдере на любом уровне. Конечно такой подход требует другого подхода к написанию компонента. Нет острой необходимости поключать Reducers в Combine. И ходить собирать их по  всему проекту. А может вы не собираете их по всем компонентам и калдете в одну директорию? Я не думаю что это сильно упрощает восприятие, в первом случае у вас опять начинаются сложные импорты (алиасы) во втором случае директория Reducers грозит разрастись до 15-20 файлов на одном уровне что не упращет ни поиск ни визуальное восприятие.

Во время моих поисков оптимального решения я наткнулся еще на один вариант он выглядит так, предложенный Robin Wieruch (ссылка вначале статьи)

```
- src/
--- App/
----- index.js
----- component.js
----- test.js
----- style.css
--- List/
----- index.js
----- component.js
----- test.js
----- style.css
----- ListItem/
------- index.js
------- component.js
------- test.js
------- style.css
```

В этом есть интересные мысли которые перекликаются с моими размышленями о структуре файлов проекта на Реакт. Но также и есть очевидные для меня недостаки. Первый который бросается мне в глаза быстрый доступ к файлам на основании имени просто отсутствует, так как большинство популярных редакторов кода и IDE дают возможность быстро открыть файл просто начал вводить его название тут вы явно не сможете этого сделать. Введите component.js в поиск при такой раскладке и выпоймете о чем я.

## К чему мы пришли
В итоге проанализировав сушествующие решения и наш опыт использования, мы выроботали собственный подход к организации файлов внутри проекта:

1. Все таки весь код лежит внутри `src`. И `src` является корневой дирректорией для всего кода. Можно зафиксировать это с помощью alias in webpack.

```
  .
  └── /src
```

Причин для выноса каких-то страниц или компонентов в `modules` нет. Любой код который должен быть вынесен в отдельный модуль приложения должен быть обсужден отдельно с помощью спецаильного фреймворка для принятия решений где будет отдельно описаны причины, последствия и процесс.

2. В корне репозитороия основное деление по названию компонента или страницы.

```
  .
  └── /src
      ├── /App
      │   └── App.ts
      ├── /Header
      │   └── Header.ts
      ├── /Portal
      │   └── Portal.ts
      └── /Creation
          └── Creation.ts
```

3. Мы отказываемся от `components`, `containers`, `stores`, `api`, `styles` вне контекста компонента. Да и внутри компонента они перестают нести организационный характер и создавать ненужную вложенность, а должны отображать назначение и содержание файла.

```
  .
  └── /src
      ├── /App
      ├── /Header
      ├── /Portal
      │   ├── Portal.api.ts
      │   ├── Portal.store.ts
      │   ├── Portal.interface.ts
      │   ├── Portal.styles.ts
      │   └── Portal.ts
      └── /Creation
```

4. Решили оставить только `assets` и `tests` для выделения файлов не относящихся непосредственно к разработке но они должны быть размешены как можно ближе к месту непосредственного использования. При желании можно использовать символ подчеркивания вначале и/или в конце названия, чтобы гарантировано поместить такие директории вначале списка файлов.

```
  .
  └── /src
      ├── /App
      ├── /Header
      ├── /Portal
      │   ├── /__tests__
      │   ├── /_assets
      │   ├── Portal.api.ts
      │   ├── Portal.store.ts
      │   ├── Portal.interface.ts
      │   ├── Portal.styles.ts
      │   └── Portal.ts
      └── /Creation
```

5. При  необходимости уменьшения длины файла для улучшения читаемости кода части логики можно вынести в отдельные файлы (допустимую длину файла лучше всего установить на уровне линтера). Такие части нужно поместить соблюдая вложенность. Допускается только один уровень вложенности для каждого компонента. Не нужно уходить на один или два уровня внутрь.

```
  .
  └── /src
      ├── /App
      ├── /Header
      ├── /Portal
      │   ├── /_tests
      │   ├── /_assets
      │   ├── /PortalSearchBar
      │   │   ├── PortalSearchBar.styles.ts
      │   │   └── PortalSearchBar.ts
      │   ├── Portal.api.ts
      │   ├── Portal.store.ts
      │   ├── Portal.interface.ts
      │   ├── Portal.styles.ts
      │   └── Portal.ts
      └── /Creation
```

## Выводы
На мой взгляд. Предложенная структура помогает разработчкику думать в парадигме MVV/MVC. Заранее планировать дизайн компонента. Тратить меньше времени на поиск компонентов как просто по дереву так и через панель быстрого доступа.

Является ли предложенная модель на 100% оптимальной и подходяшей всем? Я далек от этой мысли. Но в нашем проекте это очевидно имеет место. Поэтому если у вас мысли или замечания по этому поводу напишите мне.